<문제>

문제 설명
피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어

F(2) = F(0) + F(1) = 0 + 1 = 1
F(3) = F(1) + F(2) = 1 + 1 = 2
F(4) = F(2) + F(3) = 1 + 2 = 3
F(5) = F(3) + F(4) = 2 + 3 = 5
와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.

제한 사항
* n은 1이상, 100000이하인 자연수입니다.

입출력 예
n	return
3	2
5	5
입출력 예 설명
피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다.

<풀이>
매~우 간단하게 생각한 문제였는데 생각하지 못한 함정이 있었다.

function solution(n) {
    var answer = [];
    answer[0] = 0;
    answer[1] = 1;
    for (let i=2; i<=n; i++){
        answer.push(answer[i-1]+answer[i-2]);
    }
    return answer[n]%1234567;
}
단순히 i-1번째와 i-2번째의 값을 더한 것을 push한 후

배열에서 뽑아와서 1234567로 나눈 나머지를 return했는데
이러면 케이스 6번까지만 통과하고 7번부터는 전부 실패한다.

"문제에서 1234567로 나눈 나머지를 정답으로 내놓으라는 것은 문제를 꼰 것이 아니라 int 자료형의 범위 내에 항상 값이 있을 수 있도록 한 배려이며, 자료형의 크기에 제한이 있는 언어를 쓸 경우 (A + B) % C ≡ ( ( A % C ) + ( B % C) ) % C라는 성질을 이용해서 매번 계산 결과에 1234567으로 나눈 나머지를 대신 넣는 것으로 int 범위 내에 항상 값이 존재함을 보장할 수 있다."

이러한 이유때문에 그렇다는데.... 완전히 이해한것은 아니지만....
암튼 어차피 1234567로 나눈 나머지를 return할 것이기 때문에
값을 저장할 때부터 1234567로 나눈 값을 넣어서 저장해버리면 문제가 해결된다.

function solution(n) {
    var answer = [];
    answer[0] = 0;
    answer[1] = 1;
    for (let i=2; i<=n; i++){
        answer.push((answer[i-1]+answer[i-2])%1234567);
    }
    return answer[n];
}